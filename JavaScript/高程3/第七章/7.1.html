<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>递归</title>
  <script>
    /**
      递归
      递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。

        function factorial(num) {
          if (num <= 1) {
            return 1;
          } else {
            return num * factorial(num-1);
          }
        };
      
      这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。

        var anotherFactorial = factorial;
        factorial = null;
        console.log(factorial(4));// error

      以上代码先把factorial()函数保存在变量anotherFactorial中，然后factorial变量设置为null，
      结果指向原始函数的引用只剩下一个。但在接下来调用anotherFactorial()时，由于必须执行fact-
      orial()，而factorial已经不再是函数，所以就会导致错误。在这种情况下，使用arguments.callee
      可以解决这个问题
      我们知道，arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调
      用，例如：

        function factorial(num) {
          if (num <= 1) {
            return 1;
          } else {
            return num * arguments.callee(num - 1);
          }
        };
      
      通过使用arguments.callee代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归
      函数时，使用arguments.callee总比使用函数名更保险。
      但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命
      名函数表达式来达成相同的结果。例如：

        var factorial = (function f(num) {
          if (num <= 1) {
            return 1;
          } else {
            return num * f(num-1);
          }
        });
      
      以上代码创建一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另
      一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下
      都行得通。
    */
  </script>
</head>
<body>
  
</body>
</html>